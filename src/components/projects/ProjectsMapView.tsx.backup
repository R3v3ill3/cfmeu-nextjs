"use client"

import { useEffect, useState, useMemo, useCallback } from "react"
import { GoogleMap, Polygon, Marker, InfoWindow, Circle } from "@react-google-maps/api"
import { useQuery } from "@tanstack/react-query"
import { supabase } from "@/integrations/supabase/client"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { MapPin, Building, Users, ExternalLink, AlertCircle } from "lucide-react"
import Link from "next/link"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Palette } from "lucide-react"
import { getProjectColor, getColorSchemeLegend } from "@/utils/projectColors"
import { useGoogleMaps } from "@/providers/GoogleMapsProvider"
import { MapErrorBoundary } from "@/components/map/MapErrorBoundary"
import { useNetworkStatus } from "@/hooks/useNetworkStatus"

interface ProjectsMapViewProps {
  projects: any[]
  onProjectClick: (projectId: string) => void
  searchQuery: string
  patchIds: string[]
  tierFilter: string
  workersFilter: string
  currentFilters?: {
    q?: string
    patch?: string
    tier?: string
    universe?: string
    stage?: string
    workers?: string
    special?: string
    eba?: string
  }
  addressSearchPin?: {
    lat: number
    lng: number
    address: string
  }
  highlightedProjectIds?: string[]
}

interface PatchData {
  id: string
  name: string
  code: string
  type: string
  status: string
  geom_geojson: any
}

interface JobSiteData {
  id: string
  name: string
  location: string
  latitude: number
  longitude: number
  project_id: string
  patch_id: string | null
  projects?: {
    name: string
    tier: string | null
  }
}

const mapContainerStyle = {
  width: "100%",
  height: "70vh"
}

const defaultCenter = {
  lat: -33.8688,
  lng: 151.2093 // Sydney, Australia
}

// Color scheme for different patch types
const patchColors = {
  geo: "#ef4444", // red
  trade: "#22c55e", // green
  "sub-sector": "#3b82f6", // blue
  other: "#f97316" // orange
}

export default function ProjectsMapView({
  projects,
  onProjectClick,
  searchQuery,
  patchIds,
  tierFilter,
  workersFilter,
  currentFilters,
  addressSearchPin,
  highlightedProjectIds = []
}: ProjectsMapViewProps) {
  const [map, setMap] = useState<google.maps.Map | null>(null)
  const [selectedJobSite, setSelectedJobSite] = useState<JobSiteData | null>(null)
  const [selectedPatch, setSelectedPatch] = useState<PatchData | null>(null)
  const [infoWindowPosition, setInfoWindowPosition] = useState<{ lat: number, lng: number } | null>(null)
  const [projectColorBy, setProjectColorBy] = useState<'tier' | 'organising_universe' | 'stage' | 'builder_eba' | 'default'>('builder_eba')

  // Use centralized Google Maps context
  const { isLoaded, loadError } = useGoogleMaps()

  // Check network status
  const isOnline = useNetworkStatus()
  
  // Construct URL for Full Map page with preserved filters
  const fullMapUrl = useMemo(() => {
    const params = new URLSearchParams()
    
    // Pass all available filters (Map page currently only supports patch, but we'll pass them all)
    if (currentFilters?.patch) {
      params.set('patch', currentFilters.patch)
    }
    if (currentFilters?.q) {
      params.set('q', currentFilters.q)
    }
    if (currentFilters?.tier && currentFilters.tier !== 'all') {
      params.set('tier', currentFilters.tier)
    }
    if (currentFilters?.universe && currentFilters.universe !== 'all') {
      params.set('universe', currentFilters.universe)
    }
    if (currentFilters?.stage && currentFilters.stage !== 'all') {
      params.set('stage', currentFilters.stage)
    }
    if (currentFilters?.workers && currentFilters.workers !== 'all') {
      params.set('workers', currentFilters.workers)
    }
    if (currentFilters?.eba && currentFilters.eba !== 'all') {
      params.set('eba', currentFilters.eba)
    }
    
    const queryString = params.toString()
    return queryString ? `/map?${queryString}` : '/map'
  }, [currentFilters])

  // Get project IDs from filtered projects
  const projectIds = useMemo(() => projects.map(p => p.id), [projects])

  // Fetch job sites for the filtered projects
  const { data: jobSites = [], error: jobSitesError, isLoading: jobSitesLoading } = useQuery({
    queryKey: ["project-job-sites-for-map", projectIds],
    queryFn: async () => {
      if (projectIds.length === 0) return []
      
      const { data, error } = await supabase
        .from("job_sites")
        .select(`
          id,
          name,
          location,
          latitude,
          longitude,
          project_id,
          patch_id,
          projects:projects!fk_job_sites_project(
            name,
            tier,
            organising_universe,
            stage_class,
            builder_id,
            project_assignments:project_assignments(
              assignment_type,
              contractor_role_types(code),
              employers(name, enterprise_agreement_status)
            )
          )
        `)
        .in("project_id", projectIds)
        .not("latitude", "is", null)
        .not("longitude", "is", null)
      
      if (error) throw error
      return (data || []) as unknown as JobSiteData[]
    },
    enabled: projectIds.length > 0,
    retry: 1,
    staleTime: 30000
  })

  // Fetch all patches data with geometry for overlay display
  const { data: allPatches = [] } = useQuery<PatchData[]>({
    queryKey: ["patches-with-geometry-all"],
    queryFn: async () => {
      const { data, error } = await supabase
        .from("patches_with_geojson")
        .select("id, name, code, geom_geojson")
        .not("geom_geojson", "is", null)

      if (error) throw error

      const normalized: PatchData[] = (data || []).map((row: any) => ({
        id: row.id,
        name: row.name,
        code: row.code,
        type: "geo",
        status: "active",
        geom_geojson: row.geom_geojson
      }))

      return normalized
    },
    retry: 1,
    staleTime: 30000
  })

  // Fetch filtered patches data (only if patchIds filter is applied)
  const { data: filteredPatches = [] } = useQuery<PatchData[]>({
    queryKey: ["patches-with-geometry-filtered", patchIds],
    queryFn: async () => {
      if (patchIds.length === 0) return []
      
      const { data, error } = await supabase
        .from("patches_with_geojson")
        .select("id, name, code, geom_geojson")
        .in("id", patchIds)
        .not("geom_geojson", "is", null)

      if (error) throw error

      const normalized: PatchData[] = (data || []).map((row: any) => ({
        id: row.id,
        name: row.name,
        code: row.code,
        type: "geo",
        status: "active",
        geom_geojson: row.geom_geojson
      }))

      return normalized
    },
    enabled: patchIds.length > 0,
    retry: 1,
    staleTime: 30000
  })

  // Use filtered patches if there's a filter, otherwise show all patches as overlay
  const patches = patchIds.length > 0 ? filteredPatches : allPatches

  // Convert GeoJSON to Google Maps Polygon paths
  const extractPolygonsFromGeoJSON = useCallback((geojson: any): google.maps.LatLngLiteral[][][] => {
    try {
      if (!geojson || !geojson.type || !geojson.coordinates) return []

      const toRing = (coords: [number, number][]) => coords.map(([lng, lat]) => ({ lat, lng }))

      if (geojson.type === "Polygon") {
        const rings: google.maps.LatLngLiteral[][] = (geojson.coordinates as [number, number][][]).map(toRing)
        return [rings]
      }
      if (geojson.type === "MultiPolygon") {
        const polygons: google.maps.LatLngLiteral[][][] = (geojson.coordinates as [number, number][][][]).map(
          (poly) => (poly as [number, number][][]).map(toRing)
        )
        return polygons
      }
      return []
    } catch (e) {
      console.warn("Failed to parse GeoJSON:", e)
      return []
    }
  }, [])

  // Handle job site marker click
  const handleJobSiteClick = useCallback((jobSite: JobSiteData) => {
    setSelectedJobSite(jobSite)
    setSelectedPatch(null)
    setInfoWindowPosition({
      lat: jobSite.latitude,
      lng: jobSite.longitude
    })
  }, [])

  // Handle patch click
  const handlePatchClick = useCallback((patch: PatchData, event: google.maps.PolyMouseEvent) => {
    if (event.latLng) {
      setSelectedPatch(patch)
      setSelectedJobSite(null)
      setInfoWindowPosition({
        lat: event.latLng.lat(),
        lng: event.latLng.lng()
      })
    }
  }, [])

  // Handle map click to close info windows
  const handleMapClick = useCallback(() => {
    setSelectedJobSite(null)
    setSelectedPatch(null)
    setInfoWindowPosition(null)
  }, [])

  // Auto-fit bounds when data changes - focus on first project and ensure all are visible
  useEffect(() => {
    if (!map) return
    if (jobSites.length === 0 && !addressSearchPin) return

    const bounds = new google.maps.LatLngBounds()
    let hasPoints = false

    // Add address search pin bounds (highest priority)
    if (addressSearchPin) {
      bounds.extend({ lat: addressSearchPin.lat, lng: addressSearchPin.lng })
      hasPoints = true
    }

    // Add job site bounds
    jobSites.forEach(site => {
      bounds.extend({ lat: site.latitude, lng: site.longitude })
      hasPoints = true
    })

    // Add patch bounds if any
    patches.forEach(patch => {
      if (patch.geom_geojson) {
        const polys = extractPolygonsFromGeoJSON(patch.geom_geojson)
        polys.forEach((rings) => {
          const outer = rings[0] || []
          outer.forEach((point) => { bounds.extend(point); hasPoints = true })
        })
      }
    })

    if (hasPoints) {
      map.fitBounds(bounds)

      // After fitting bounds, ensure minimum zoom to show all projects
      setTimeout(() => {
        const currentZoom = map.getZoom() || 10
        if (currentZoom > 15) {
          map.setZoom(15) // Max zoom to keep context
        }
      }, 100)
    }
  }, [map, jobSites, patches, addressSearchPin, extractPolygonsFromGeoJSON])

  // Deterministic color per patch id
  const colorForPatch = useCallback((patchId: string) => {
    let hash = 0
    for (let i = 0; i < patchId.length; i++) hash = (hash * 31 + patchId.charCodeAt(i)) >>> 0
    const hue = hash % 360
    return `hsl(${hue} 80% 60%)`
  }, [])

  const mapOptions = useMemo(() => ({
    disableDefaultUI: false,
    clickableIcons: false,
    mapTypeId: "roadmap",
    styles: [
      {
        featureType: "poi",
        elementType: "labels",
        stylers: [{ visibility: "off" }]
      }
    ]
  }), [])

  // Handle offline state
  if (!isOnline) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="flex flex-col items-center justify-center h-[500px] bg-yellow-50 rounded-lg border-2 border-yellow-200">
            <AlertCircle className="h-12 w-12 text-yellow-600 mb-4" />
            <h3 className="text-lg font-semibold mb-2">You are offline</h3>
            <p className="text-sm text-yellow-800 text-center max-w-md px-4">
              Map features require an internet connection. Please check your network and try again.
            </p>
          </div>
        </CardContent>
      </Card>
    )
  }

  // Handle loading states
  if (loadError) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="flex flex-col items-center justify-center h-[500px] bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
            <AlertCircle className="h-12 w-12 text-red-500 mb-4" />
            <h3 className="text-lg font-semibold mb-2">Map Failed to Load</h3>
            <p className="text-sm text-gray-600 mb-4 max-w-md text-center px-4">
              {loadError.message || 'There was an error loading Google Maps. You can still use card and list views.'}
            </p>
            <p className="text-xs text-gray-500 mb-4">
              Please check your internet connection or try refreshing the page.
            </p>
          </div>
        </CardContent>
      </Card>
    )
  }

  if (!isLoaded) {
    return (
      <Card>
        <CardContent className="p-6 text-center">
          <div className="flex items-center justify-center">
            <div className="text-center">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-2"></div>
              <p className="text-gray-600">Loading map...</p>
            </div>
          </div>
        </CardContent>
      </Card>
    )
  }

  if (jobSites.length === 0 && !jobSitesLoading) {
    return (
      <Card>
        <CardContent className="p-6 text-center">
          <div className="text-center">
            <MapPin className="h-12 w-12 text-gray-400 mx-auto mb-4" />
            <p className="text-gray-600">No projects with location data found for the current filters.</p>
          </div>
        </CardContent>
      </Card>
    )
  }

  const deriveBuilderStatus = (project: any): 'active_builder' | 'inactive_builder' | 'unknown_builder' => {
    return project?.builder_status || 'unknown_builder';
  }

  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="flex items-center justify-between flex-wrap gap-3">
          <div className="flex items-center gap-2">
            <MapPin className="h-5 w-5" />
            <span>Projects Map</span>
            <Badge variant="outline" className="text-xs">
              {jobSites.length} location{jobSites.length !== 1 ? 's' : ''}
            </Badge>
          </div>
          <div className="flex items-center gap-2 flex-wrap">
            <Link href={fullMapUrl}>
              <Button variant="outline" size="sm" className="gap-2">
                <ExternalLink className="h-4 w-4" />
                Full Map
              </Button>
            </Link>
            <div className="flex items-center gap-2">
              <Palette className="h-4 w-4 text-gray-500" />
              <Select value={projectColorBy} onValueChange={(value) => setProjectColorBy(value as typeof projectColorBy)}>
                <SelectTrigger className="w-48">
                  <SelectValue placeholder="Color projects by..." />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="default">Default (Blue)</SelectItem>
                  <SelectItem value="tier">Tier</SelectItem>
                  <SelectItem value="organising_universe">Organising Universe</SelectItem>
                  <SelectItem value="stage">Stage</SelectItem>
                  <SelectItem value="builder_eba">Builder EBA Status</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </CardTitle>
      </CardHeader>
      <CardContent className="p-0">
        <MapErrorBoundary>
          <GoogleMap
          mapContainerStyle={mapContainerStyle}
          center={defaultCenter}
          zoom={10}
          options={mapOptions}
          onLoad={setMap}
          onClick={handleMapClick}
        >
          {/* Render Address Search Pin and Radius */}
          {addressSearchPin && (
            <>
              {/* Search Radius Circle (100km) */}
              <Circle
                center={{ lat: addressSearchPin.lat, lng: addressSearchPin.lng }}
                radius={100000} // 100km in meters
                options={{
                  fillColor: "#3b82f6",
                  fillOpacity: 0.1,
                  strokeColor: "#3b82f6",
                  strokeOpacity: 0.4,
                  strokeWeight: 2,
                  clickable: false
                }}
              />

              {/* Search Pin Marker */}
              <Marker
                position={{ lat: addressSearchPin.lat, lng: addressSearchPin.lng }}
                icon={{
                  url: "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(`
                    <svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <circle cx="16" cy="16" r="12" fill="#ef4444" stroke="#ffffff" stroke-width="3"/>
                      <path d="M16 8 L20 14 L12 14 Z" fill="#ffffff"/>
                    </svg>
                  `),
                  scaledSize: new google.maps.Size(32, 32),
                  anchor: new google.maps.Point(16, 16)
                }}
                onClick={() => {
                  setInfoWindowPosition({ lat: addressSearchPin.lat, lng: addressSearchPin.lng })
                  setSelectedJobSite(null)
                  setSelectedPatch(null)
                }}
              />
            </>
          )}

          {/* Render Patches as Polygons */}
          {patches.map(patch => {
            if (!patch.geom_geojson) return null

            const polygons = extractPolygonsFromGeoJSON(patch.geom_geojson)
            if (polygons.length === 0) return null

            const color = colorForPatch(patch.id)
            return (
              <div key={patch.id}>
                {polygons.map((rings, idx) => (
                  <Polygon
                    key={`${patch.id}-${idx}`}
                    paths={rings}
                    options={{
                      fillColor: color,
                      fillOpacity: 0.2,
                      strokeColor: "#000000",
                      strokeOpacity: 1,
                      strokeWeight: 2,
                      clickable: true
                    }}
                    onClick={(event) => handlePatchClick(patch, event)}
                  />
                ))}
              </div>
            )
          })}

          {/* Render Job Sites as Markers */}
          {jobSites.map(site => {
            const project = site.projects || {}
            if (projectColorBy === 'builder_eba') {
              const status = deriveBuilderStatus(project)
              const color = getProjectColor('builder_eba', { builder_status: status } as any)
              const useFavicon = status === 'active_builder'
              const icon = useFavicon
                ? { url: '/favicon.ico', scaledSize: new google.maps.Size(24, 24), anchor: new google.maps.Point(12, 12) }
                : {
                    url: "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(`
                      <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                        <circle cx=\"12\" cy=\"12\" r=\"8\" fill=\"${color}\" stroke=\"#ffffff\" stroke-width=\"2\"/>\n                        <circle cx=\"12\" cy=\"12\" r=\"3\" fill=\"#ffffff\"/>\n                      </svg>\n                    `),
                    scaledSize: new google.maps.Size(24, 24),
                    anchor: new google.maps.Point(12, 12)
                  }
              return (
                <Marker
                  key={site.id}
                  position={{ lat: site.latitude, lng: site.longitude }}
                  icon={icon as any}
                  onClick={() => handleJobSiteClick(site)}
                />
              )
            }
            const color = getProjectColor(projectColorBy, project as any)
            return (
              <Marker
                key={site.id}
                position={{ lat: site.latitude, lng: site.longitude }}
                icon={{
                  url: "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(`
                    <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n                      <circle cx=\"12\" cy=\"12\" r=\"8\" fill=\"${color}\" stroke=\"#ffffff\" stroke-width=\"2\"/>\n                      <circle cx=\"12\" cy=\"12\" r=\"3\" fill=\"#ffffff\"/>\n                    </svg>\n                  `),
                  scaledSize: new google.maps.Size(24, 24),
                  anchor: new google.maps.Point(12, 12)
                }}
                onClick={() => handleJobSiteClick(site)}
              />
            )
          })}

          {/* Info Window for Job Sites */}
          {selectedJobSite && infoWindowPosition && (
            <InfoWindow
              position={infoWindowPosition}
              onCloseClick={() => {
                setSelectedJobSite(null)
                setInfoWindowPosition(null)
              }}
            >
              <div className="p-2 min-w-[250px]">
                <div className="flex items-start justify-between mb-2">
                  <h3 className="font-semibold text-lg">{selectedJobSite.name}</h3>
                  <MapPin className="h-5 w-5 text-blue-600" />
                </div>
                <p className="text-sm text-gray-600 mb-2">{selectedJobSite.location}</p>
                {selectedJobSite.projects && (
                  <div className="mb-2">
                    <p className="text-sm text-gray-600">
                      Project: {selectedJobSite.projects.name}
                    </p>
                    {selectedJobSite.projects.tier && (
                      <Badge variant="outline" className="text-xs mt-1">
                        {selectedJobSite.projects.tier}
                      </Badge>
                    )}
                  </div>
                )}
                <div className="flex gap-2">
                  <Button 
                    size="sm" 
                    variant="outline" 
                    className="flex items-center gap-2"
                    onClick={() => onProjectClick(selectedJobSite.project_id)}
                  >
                    <Building className="h-3 w-3" />
                    View Project
                  </Button>
                  {selectedJobSite.patch_id && (
                    <Link href={`/patch?patch=${selectedJobSite.patch_id}`}>
                      <Button size="sm" variant="outline" className="flex items-center gap-2">
                        <Users className="h-3 w-3" />
                        View Patch
                      </Button>
                    </Link>
                  )}
                </div>
              </div>
            </InfoWindow>
          )}

          {/* Info Window for Patches */}
          {selectedPatch && infoWindowPosition && (
            <InfoWindow
              position={infoWindowPosition}
              onCloseClick={() => {
                setSelectedPatch(null)
                setInfoWindowPosition(null)
              }}
            >
              <div className="p-2 min-w-[250px]">
                <div className="flex items-start justify-between mb-2">
                  <h3 className="font-semibold text-lg">{selectedPatch.name}</h3>
                  <Badge 
                    variant="secondary"
                    style={{ 
                      backgroundColor: patchColors[selectedPatch.type as keyof typeof patchColors] || patchColors.other,
                      color: "white"
                    }}
                  >
                    {selectedPatch.type}
                  </Badge>
                </div>
                <p className="text-sm text-gray-600 mb-2">Code: {selectedPatch.code}</p>
                <p className="text-sm text-gray-600 mb-3">Status: {selectedPatch.status}</p>
                <Link href={`/patch?patch=${selectedPatch.id}`}>
                  <Button size="sm" className="flex items-center gap-2">
                    <ExternalLink className="h-3 w-3" />
                    View Patch Details
                  </Button>
                </Link>
              </div>
            </InfoWindow>
          )}
        </GoogleMap>
        </MapErrorBoundary>
      </CardContent>
      {projectColorBy !== 'default' && (
        <div className="p-4">
          <div className="text-sm font-medium mb-2">Project Colour Legend</div>
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
            {getColorSchemeLegend(projectColorBy).map(({ label, color }) => {
              if (projectColorBy === 'builder_eba' && label.startsWith('Builder = EBA active')) {
                return (
                  <div key={label} className="flex items-center gap-2">
                    <img src="/favicon.ico" alt="Active EBA" className="w-4 h-4" />
                    <span className="text-sm">{label}</span>
                  </div>
                )
              }
              return (
                <div key={label} className="flex items-center gap-2">
                  <div className="w-4 h-4 rounded-full border-2 border-white shadow-sm" style={{ backgroundColor: color }} />
                  <span className="text-sm">{label}</span>
                </div>
              )
            })}
          </div>
        </div>
      )}
    </Card>
  )
}
